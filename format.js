/*************** AUTOGENERATED @ 1274253127356 ***************
    WARNING: THIS FILE WAS AUTOGENERATED BY THE FORMAT BUILD SCRIPT
    MODIFYING THIS FILE IS FINE, BUT YOU REALLY SHOULD BE MODIFYING 
    THE LIBRARY DIRECTLY AND REGENERATING THIS FILE USING BUILD.js!!!!
    format.js - Written by Marak Squires
 
*/
var format = {};
format.version = "0.0.1";
format.types = {};
format.types.isNumber = function ( numbery ){
  
  if(numbery.toString() == 'NaN'){
    return false;  
  }
  if(numbery instanceof Number){
    return true; 
  }
  else{
    return false;
  }
  
};

format.types.isText = function (){
  
};

format.inflector = {};
format.inflector.camelize = function (){};

format.inflector.classify = function (){};

format.inflector.constantize = function (){};

format.inflector.dasherize = function (){};

format.inflector.demodulize = function (){};

format.inflector.foreign_key = function (){};

format.inflector.humanize = function (){};

format.inflector.inflections = function (){};

format.inflector.ordinalize = function (){};

format.inflector.pluralize = function ( str ){};

format.inflector.singularize = function (){};

format.inflector.tableize = function (){};

format.inflector.titleize = function (){};

format.inflector.underscore = function (){};

format.number = {};
format.number.toNumber = function (numbery){
  
  var n = numbery;
  n = n.toString();
  n = n.replace( /\,/g, '' );
  n = n.replace( /\$/g, '' ); // replace with format.currency.toCurrency call
  n =  new Number(n);

  if(n.toString() == 'NaN'){
    return false;
  }
  else{
    return n;
    
  }
};

format.number.toPercent = function (number){
  // TODO: add more stripping and formatting logic
  return number;
};

format.string = {};
format.string.stripNumbers = function ( str ){
  return str.replace(/[^A-Za-z]/g, "");
};

format.string.getNumbers = function ( str ){
  var result = str.match(/\d+/g)
  
  str = '';
  
  for(s in result){
    str += result[s];   
  }
  
  sys.puts(str);
  
  return str;
  

};

format.string.stripLetters = function ( str ){
  return 
};

format.string.getLetters = function ( str ){
  
};

format.date = {};
format.date.toDate = function (datey){
  // TODO: add more stripping and formatting logic
  return timey;
};

format.date.getMonthNumberFromName = function (datey){
 var n=exports.CultureInfo.monthNames,m=exports.CultureInfo.abbreviatedMonthNames,s=datey.toLowerCase();
 for(var i=0;i<n.length;i++){
   if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){
     return i;
     }
    }
  return-1;
};

format.date.getDayNumberFromName = function (name){var n=exports.CultureInfo.dayNames,m=exports.CultureInfo.abbreviatedDayNames,o=exports.CultureInfo.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};

format.date.CultureInfo = [object Object];

format.date.isLeapYear = function (year){return(((year%4===0)&&(year%100!==0))||(year%400===0));};

format.date.getDaysInMonth = function (year,month){return[31,(exports.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};

format.date.getTimezoneOffset = function (s,dst){return(dst||false)?exports.CultureInfo.abbreviatedTimeZoneDST[s.toUpperCase()]:exports.CultureInfo.abbreviatedTimeZoneStandard[s.toUpperCase()];};

format.date.getTimezoneAbbreviation = function (offset,dst){var n=(dst||false)?exports.CultureInfo.abbreviatedTimeZoneDST:exports.CultureInfo.abbreviatedTimeZoneStandard,p;for(p in n){if(n[p]===offset){return p;}}
return null;};

format.date._validate = function (value,min,max,name){if(typeof value!="number"){throw new TypeError(value+" is not a Number.");}else if(value<min||value>max){throw new RangeError(value+" is not a valid value for "+name+".");}
return true;};

format.date.validateMillisecond = function (n){return exports._validate(n,0,999,"milliseconds");};

format.date.validateSecond = function (n){return exports._validate(n,0,59,"seconds");};

format.date.validateMinute = function (n){return exports._validate(n,0,59,"minutes");};

format.date.validateHour = function (n){return exports._validate(n,0,23,"hours");};

format.date.validateDay = function (n,year,month){return exports._validate(n,1,exports.getDaysInMonth(year,month),"days");};

format.date.validateMonth = function (n){return exports._validate(n,0,11,"months");};

format.date.validateYear = function (n){return exports._validate(n,1,9999,"seconds");};

format.date.now = function (){return new Date();};

format.date.today = function (){return exports.now().clearTime();};

format.date.Parsing = [object Object];

format.date.Grammar = [object Object];

format.date.Translator = [object Object];

format.date._parse = 
format.date.parse = function (s){var r=null;if(!s){return null;}
try{r=exports.Grammar.start.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};

format.date.getParseFunction = function (fx){var fn=exports.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};

format.date.parseExact = function (s,fx){return exports.getParseFunction(fx)(s);};

format.time = {};
format.time.toTime = function (timey){
  // TODO: add more stripping and formatting logic
  return timey;
};

format.time.toSeconds = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.time.toMinutes = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.time.toHours = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.time.toDays = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.time.toMonths = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.time.toYears = function (timey){
    // TODO: add more stripping and formatting logic
    return timey;
  };

format.currency = {};
format.currency.toDollars = function (money){
  // TODO: add more stripping and formatting logic
  return money;
};

format.currency.toPennies = function (money){
    // TODO: add more stripping and formatting logic
    return money;
  };

format.currency.toNickels = function (money){
    // TODO: add more stripping and formatting logic
    return money;
  };

format.currency.toDimes = function (money){
    // TODO: add more stripping and formatting logic
    return money;
  };

format.currency.toQuarters = function (money){
    // TODO: add more stripping and formatting logic
    return money;
  };

format.currency.toEuros = function (money){
  // TODO: add more stripping and formatting logic
  return money;
};

format.currency.toCanadian = function (money){
  // TODO: add more stripping and formatting logic
  return money;
};
if(typeof exports != "undefined"){for(var prop in format){exports[prop] = format[prop];}}