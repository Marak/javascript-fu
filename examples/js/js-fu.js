/*************** AUTOGENERATED @ 1275254641479 ***************
    WARNING: THIS FILE WAS AUTOGENERATED BY THE JS-FU BUILD SCRIPT
    MODIFYING THIS FILE IS FINE, BUT YOU REALLY SHOULD BE MODIFYING 
    THE LIBRARY DIRECTLY AND REGENERATING THIS FILE USING BUILD.js!!!!
    Javascript-fu - Written by Marak Squires
 
*/
var fu = {};
fu.version = "0.0.1";
fu.isDefined = function ( objecty ){	
  if(typeof objecty == 'undefined'){
    return false;
  }
  if(objecty == null || objecty == 'null'){
    return false;
  }
  if(objecty.toString() == 'NaN'){
    return false;  
  }
  return true;
};
fu.isNull = function (obj) {
   return obj === null || obj == 'null';
 };
fu.isNumber = function ( obj ){
  return (obj === +obj) || (toString.call(obj) === '[object Number]');
};
fu.isString = function ( stringy ){
  return !!(stringy === '' || (stringy && stringy.charCodeAt && stringy.substr));
};
fu.isRegExp = function (obj){
  return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));
};
fu.isText = function ( texty ){
 	if(!(this.isString(texty))) {
		return false;
	}
	var textyLength = texty.length;
	if(texty.replace(/[^\w\s\.\?\!\,\;\:\'\"]/g, "").length == textyLength){
   return true;  
 }
	return false;
};
fu.isDate = function ( datey ){
  return !!(datey && datey.getTimezoneOffset && datey.setUTCFullYear);
};
fu.isArray = function (obj){
	return !!(obj && obj.concat && obj.unshift && !obj.callee);
};
fu.isJSON = function (jsony){
};
fu.isNaN = function (obj) {
  return this.isNumber(obj) && isNaN(obj);
};
fu.isObject = function (objecty){
	if(this.isFunction(objecty)) {
		return false; 
	}
	if(this.isArray(objecty)) {
		return false;
	}
  return typeof objecty == 'object';
};
fu.isFunction = function (functiony){
  return !!(functiony && functiony.constructor && functiony.call && functiony.apply);
};
fu.isEmpty = function (obj){
  if (this.isString(obj)) return obj.length === 0;
  if (this.isArray(obj)) return obj.length === 0;
  for (var key in obj) { 
    if (hasOwnProperty.call(obj, key)){ 
      return false;
      }
    };
  return true;
};
fu.isNode = function (){
  return !!(obj && obj.nodeType == 1);
};
fu.isBoolean = function (obj){
  return obj === true || obj === false;
};
fu.isEqual = function (a , b){
  // Perform a deep comparison to check if two objects are equal.
    // Check object identity.
    if (a === b) return true;
    // Different types?
    var atype = typeof(a), btype = typeof(b);
    if (atype != btype) return false;
    // Basic equality test (watch out for coercions).
    if (a == b) return true;
    // One is falsy and the other truthy.
    if ((!a && b) || (a && !b)) return false;
    // One of them implements an isEqual()?
    //if (a.isEqual) return a.isEqual(b);
    // Check dates' integer values.
    if (this.isDate(a) && this.isDate(b)) return a.getTime() === b.getTime();
    // Both are NaN?
    if (this.isNaN(a) && this.isNaN(b)) return true;

    
    // Compare regular expressions.
    if (this.isRegExp(a) && this.isRegExp(b)) {
      return a.source     === b.source &&
             a.global     === b.global &&
             a.ignoreCase === b.ignoreCase &&
             a.multiline  === b.multiline;
           }
    
    /**/
    // If a is not an object by this point, we can't handle it.
    if (a instanceof Object != true) return false;
    
    // Check for different array lengths before comparing contents.
    if (a.length && (a.length != b.length)) return false;
    
    
    // Nothing else worked, deep compare the contents.
    var aKeys = getFu.getKeys(a), bKeys = getFu.getKeys(b);
    // Different object sizes?
    if (aKeys.length != bKeys.length) return false;
    // Recursive comparison of contents.
    for (var key in a) {
      if (!(key in b) || !this.isEqual(a[key], b[key])) 
      return false;
    }
   
    return true;
};
fu.toLink = function ( str ){
  return str.replace(/(^|\s)((?:f|ht)tps?:\/\/[^\s]+)/g, replacement || '$1<a href="$2">$2</a>');
};
fu.toJSON = function ( str ){
  return (JSON.stringify(str));
};
fu.toNumber = function (numbery){

  // currently not using parseFloat, parseInt, or toFixed
  var n = numbery;
  n = n.toString();
  n = n.replace( /\,/g, '' );
  n = n.replace( /\$/g, '' ); // replace with format.currency.toCurrency call
  var number = new Number(n);

  if(number.toString() == 'NaN'){
    // since we failed at getting a number, we can try to extract the digits out of the input
    //number = fu.getNumbers(number);
    return false;
  }
  else{
    return n;
    
  }
};
fu.compact = function (array) {
    return _.filter(array, function(value){ return !!value; });
  };
fu.flatten = function (array) {
    return _.reduce(array, [], function(memo, value) {
      if (_.isArray(value)) return memo.concat(_.flatten(value));
      memo.push(value);
      return memo;
    });
  };
fu.uniq = function (array, isSorted) {
    return _.reduce(array, [], function(memo, el, i) {
      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) memo.push(el);
      return memo;
    });
  };
fu.intersect = function (array) {
    var rest = _.rest(arguments);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };
fu.lastIndexOf = function (array, item) {
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
    var i = array.length;
    while (i--) { 
      if(array[i] === item) {
        return i;
        }
      }
    return -1;
  };
fu.range = function (start, stop, step) {
    var a     = _.toArray(arguments);
    var solo  = a.length <= 1;
    var start = solo ? 0 : a[0], stop = solo ? a[0] : a[1], step = a[2] || 1;
    var len   = Math.ceil((stop - start) / step);
    if (len <= 0) return [];
    var range = new Array(len);
    for (var i = start, idx = 0; true; i += step) {
      if ((step > 0 ? i - stop : stop - i) >= 0) return range;
      range[idx++] = i;
    }
  };
fu.toPercent = function (number){
  // TODO: add more stripping and formatting logic
  return number;
};
fu.toCamel = function (str) {
  return exports.toTitle(str).replace(/[^\w]/, '');
};
fu.toDash = function (str) {
  str = str.replace(/_/g, '-');
  return str;
};
fu.toHuman = function (str) {
  str = str.replace(/_id$/, "").replace(/_/, " ");
  return str.charAt(0).toUpperCase() + str.slice(1);
};
fu.toOrdinal = function (str) {
  str = str.toString();
  var num = parseInt(str, 10),
      mod100 = num % 100,
      mod10 = num % 10;
  
  switch(mod100){
    case 11:
    case 12:
    case 13:
      return str + "th";
  }
  
  switch(mod10){
    case 1:
      return str + "st";
    case 2:
      return str + "nd";
    case 3:
      return str + "rd";
  }
  
  return str + "th";
};
fu.toTitle = function (str) {

  str = exports.toUnderscore(str);
  str = exports.toHuman(str);
  
	var parts = str.split(/\b('?[a-z])/);
	str = '';

	for (var i = 0; i < parts.length; i = i + 1) {
		if ((i % 2) === 0) {
			str = str + parts[i];
		} else {
			str = str + parts[i].charAt(0).toUpperCase() + parts[i].slice(1);
		}
	};

	return str;
};
fu.toParam = function (str){
  var separator = '-';
  str = str.replace(/[^a-z0-9\-_]+/ig, separator);
  if(separator.length){
  
    str = str.replace(/-{2,}/g, separator);
    str = str.replace(/^-|-$/ig, '');
  }
  
  return str.toLowerCase();
};
fu.toUnderscore = function (str) {
	str = str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2');
	str = str.replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/-/g, "_");
	str = str.toLowerCase();
	return str;
};
fu.toPlural = function (str) {
	for (var i = inflections.uncountables.length - 1; i >= 0; i--) {
		if (str.match(inflections.uncountables[i])) return str;
	};

	var pairs = inflections.plurals,
		pair = [];

	//go from the end of the array to the front so the last pairs have priority
	for (i = pairs.length - 1; i >= 0; i--) {
		pair = pairs[i];
		var result = str.replace(pair[0], pair[1]);
		if (result === str) {
			continue;
		} else return result;
	};

	return str.replace(/([^s])$/i, '$1s');
};
fu.toSingle = function (str) {
	for (var u = inflections.uncountables.length - 1; u >= 0; u--) {
		if (str.match(inflections.uncountables[u])) return str;
	};

	var pairs = inflections.singulars,
		pair = [];

	//go from the end of the array to the front so the last pairs have priority
	for (var i = pairs.length - 1; i >= 0; i--) {
		pair = pairs[i];
		var result = str.replace(pair[0], pair[1]);
		if (result === str) {
			continue;
		} else return result;
	};

	return str.replace(/s$/i, '');
};
fu.toReverse = function ( object ){
 	if(isFu.isArray(object)) {
		return object.reverse();
	}
	if(isFu.isString(object)) {
		return object.split("").reverse().join("");
	}
	if(isFu.isNumber(object)) {
		return this.toNumber(("" + object).split("").reverse().join(""));
	}
};
fu.toWrap = function ( m, b, c ){
  
      var i, j, l, s, r;
      if(m < 1)
          return this;
      for(i = -1, l = (r = this.split("\n")).length; ++i < l; r[i] += s)
          for(s = r[i], r[i] = ""; s.length > m; r[i] += s.slice(0, j) + ((s = s.slice(j)).length ? b : ""))
              j = c == 2 || (j = s.slice(0, m + 1).match(/\S*(\s)?$/))[1] ? m : j.input.length - j[0].length
              || c == 1 && m || j.input.length + (j = s.slice(m).match(/^\S*/)).input.length;
      return r.join("\n");
  
};
fu.toTrim = function ( str ){
  return str;
};
fu._arrayShuffle = function (o){ 
	for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
	return o;
};
fu.toShuffle = function ( object ){
  if(isFu.isArray(object)) {
		return this._arrayShuffle(object);
	}
	if(isFu.isString(object)) {
		return this._arrayShuffle(object.split("")).join("");
	}
	if(isFu.isNumber(object)) {
		return this.toNumber(this._arrayShuffle(("" + object).split("")).join(""));
	}
};
fu.toChain = function (){
  //TODO: add chain >.<
};
fu.toMix = function (){
  // TODO: write tests and better possibly better shallow copy. add option for deep copy
	// copy reference to target object
	var target = arguments[0] || {}, i = 1, length = arguments.length, deep = false, options, name, src, copy;

	// Handle a deep copy situation
	if ( isFu.isBoolean(target)) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFu.isFunction(target) ) {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging object literal values or arrays
				if ( deep && copy && ( isFu.isObject(copy) || isFu.isArray(copy) ) ) {
					var clone = src && ( isFu.isObject(src) || isFu.isArray(src) ) ? src
						: isFu.isArray(copy) ? [] : {};

					// Never move original objects, clone them
					target[ name ] = this.toMix( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};
fu.getLeft = function ( str, n ){
  return str;
};
fu.getRight = function ( str, n ){
  return str;
};
fu.getLinks = function ( str ){
  return str;
};
fu.getNode = function ( selector ){
  return str;
};
fu.getRandom = function (range) {
		r = Math.floor(Math.random()*range);
		return r;
};
fu.getKeys = function ( object ) {
  keys = [];
  for (var key in object) {
    keys.push(key);
  }
  return keys;
};
fu.getValues = function ( object ) {
  values = [];
   for (var key in object) {
     values.push(object[key]);
   }
   return values;
};
fu.getFirst = function ( array ){
  if(isFu.isArray(array)) {
    return array[0];
  }
  else {
    return null;
  }
};
fu.getLast = function ( array ){
  if(isFu.isArray(array)) {
    return array[array.length - 1];  }
  else { 
    return null
  ;}
};
fu.getIndex = function ( array, item ){
   for (var i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;
   return -1;
};
fu.getFunctions = function ( object ){
  
};
if(typeof exports != "undefined"){for(var prop in fu){exports[prop] = fu[prop];}}Date.prototype.format = function (mask, utc) {return fu.dateFormat(this, mask, utc);}